From 6470dabd18f40e75cc9219f3911da929514557ce Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andreas=20M=C3=BCller?= <schnitzeltony@googlemail.com>
Date: Fri, 13 Jun 2014 21:11:37 +0200
Subject: [PATCH 4/6] omap_drm: open door for pvr
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

[1] http://lists.freedesktop.org/archives/dri-devel/2011-September/014087.html

Signed-off-by: Andreas MÃ¼ller <schnitzeltony@googlemail.com>
---
 drivers/gpu/drm/omapdrm/omap_drv.c | 129 ++++++++++++++++++++++++++++++++++++-
 drivers/gpu/drm/omapdrm/omap_drv.h |   2 +
 drivers/gpu/drm/omapdrm/omap_gem.c | 110 +++++++++++++++++++++++++++----
 include/uapi/drm/omap_drm.h        |  72 +++++++++++++++++++++
 4 files changed, 296 insertions(+), 17 deletions(-)

diff --git a/drivers/gpu/drm/omapdrm/omap_drv.c b/drivers/gpu/drm/omapdrm/omap_drv.c
index bf39fcc..ac24d3e 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.c
+++ b/drivers/gpu/drm/omapdrm/omap_drv.c
@@ -30,8 +30,17 @@
 #define DRIVER_MINOR		0
 #define DRIVER_PATCHLEVEL	0
 
+LIST_HEAD(plugin_list);
+
+/* keep track of whether we are already loaded.. we may need to call
+ * plugin's load() if they register after we are already loaded
+ */
+static bool loaded = false;
+
 static int num_crtc = CONFIG_DRM_OMAP_NUM_CRTCS;
 
+static struct drm_device *drm_device;
+
 MODULE_PARM_DESC(num_crtc, "Number of overlays to use as CRTCs");
 module_param(num_crtc, int, 0600);
 
@@ -439,7 +448,7 @@ static int ioctl_gem_info(struct drm_device *dev, void *data,
 	return ret;
 }
 
-static const struct drm_ioctl_desc ioctls[DRM_COMMAND_END - DRM_COMMAND_BASE] = {
+static struct drm_ioctl_desc ioctls[DRM_COMMAND_END - DRM_COMMAND_BASE] = {
 	DRM_IOCTL_DEF_DRV(OMAP_GET_PARAM, ioctl_get_param, DRM_UNLOCKED|DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(OMAP_SET_PARAM, ioctl_set_param, DRM_UNLOCKED|DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
 	DRM_IOCTL_DEF_DRV(OMAP_GEM_NEW, ioctl_gem_new, DRM_UNLOCKED|DRM_AUTH),
@@ -466,10 +475,13 @@ static int dev_load(struct drm_device *dev, unsigned long flags)
 {
 	struct omap_drm_platform_data *pdata = dev->dev->platform_data;
 	struct omap_drm_private *priv;
+	struct omap_drm_plugin *plugin;
 	int ret;
 
 	DBG("load: dev=%p", dev);
 
+	drm_device = dev;
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -507,15 +519,27 @@ static int dev_load(struct drm_device *dev, unsigned long flags)
 
 	drm_kms_helper_poll_init(dev);
 
+	loaded = true;
+
+	list_for_each_entry(plugin, &plugin_list, list) {
+		ret = plugin->load(dev, flags);
+	}
+
 	return 0;
 }
 
 static int dev_unload(struct drm_device *dev)
 {
 	struct omap_drm_private *priv = dev->dev_private;
+	struct omap_drm_plugin *plugin;
+	int ret;
 
 	DBG("unload: dev=%p", dev);
 
+	list_for_each_entry(plugin, &plugin_list, list) {
+		ret = plugin->unload(dev);
+	}
+
 	drm_kms_helper_poll_fini(dev);
 
 	omap_fbdev_free(dev);
@@ -532,15 +556,36 @@ static int dev_unload(struct drm_device *dev)
 
 	dev_set_drvdata(dev->dev, NULL);
 
+	loaded = false;
+
 	return 0;
 }
 
 static int dev_open(struct drm_device *dev, struct drm_file *file)
 {
+	struct omap_drm_plugin *plugin;
+	bool found_pvr = false;
+	int ret;
+
 	file->driver_priv = NULL;
 
 	DBG("open: dev=%p, file=%p", dev, file);
 
+	list_for_each_entry(plugin, &plugin_list, list) {
+		if (!strcmp(DRIVER_NAME "_pvr", plugin->name)) {
+			found_pvr = true;
+			break;
+		}
+	}
+
+	if (!found_pvr) {
+		DBG("open: PVR submodule not loaded.. let's try now");
+		request_module(DRIVER_NAME "_pvr");
+	}
+
+	list_for_each_entry(plugin, &plugin_list, list) {
+		ret = plugin->open(dev, file);
+	}
 	return 0;
 }
 
@@ -596,13 +641,20 @@ static void dev_preclose(struct drm_device *dev, struct drm_file *file)
 
 static void dev_postclose(struct drm_device *dev, struct drm_file *file)
 {
+	struct omap_drm_plugin *plugin;
+	int ret;
+
 	DBG("postclose: dev=%p, file=%p", dev, file);
+
+	list_for_each_entry(plugin, &plugin_list, list) {
+		ret = plugin->release(dev, file);
+	}
 }
 
 static const struct vm_operations_struct omap_gem_vm_ops = {
 	.fault = omap_gem_fault,
-	.open = drm_gem_vm_open,
-	.close = drm_gem_vm_close,
+	.open = omap_gem_vm_open,
+	.close = omap_gem_vm_close,
 };
 
 static const struct file_operations omapdriver_fops = {
@@ -656,6 +708,77 @@ static struct drm_driver omap_drm_driver = {
 		.patchlevel = DRIVER_PATCHLEVEL,
 };
 
+int omap_drm_register_plugin(struct omap_drm_plugin *plugin)
+{
+	struct drm_device *dev = drm_device;
+	static int ioctl_base = DRM_OMAP_NUM_IOCTLS;
+	int i;
+
+	DBG("register plugin: %p (%s)", plugin, plugin->name);
+
+	plugin->ioctl_base = ioctl_base;
+
+	list_add_tail(&plugin->list, &plugin_list);
+
+	/* register the plugin's ioctl's */
+	for (i = 0; i < plugin->num_ioctls; i++) {
+		int nr = i + ioctl_base;
+
+		/* check for out of bounds ioctl nr or already registered ioctl */
+		if (nr > ARRAY_SIZE(ioctls) || ioctls[nr].func) {
+			dev_err(dev->dev, "invalid ioctl: %d (nr=%d)\n", i, nr);
+			return -EINVAL;
+		}
+
+		DBG("register ioctl: %d %08x", nr, plugin->ioctls[i].cmd);
+
+		ioctls[nr] = plugin->ioctls[i];
+
+		if (nr >= omap_drm_driver.num_ioctls) {
+			omap_drm_driver.num_ioctls = nr + 1;
+		}
+	}
+
+	ioctl_base += plugin->num_ioctls;
+
+	if (loaded) {
+		plugin->load(dev, 0);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_drm_register_plugin);
+
+int omap_drm_unregister_plugin(struct omap_drm_plugin *plugin)
+{
+	list_del(&plugin->list);
+	/* TODO remove ioctl fxns */
+	return 0;
+}
+EXPORT_SYMBOL(omap_drm_unregister_plugin);
+
+static int nmappers = 0;
+
+/* create buffer mapper id, to access per-mapper private data.  See
+ * omap_gem_{get,set}_priv().
+ */
+int omap_drm_register_mapper(void)
+{
+	if (nmappers >= MAX_MAPPERS) {
+		return -ENOMEM;
+	}
+	return nmappers++;
+}
+EXPORT_SYMBOL(omap_drm_register_mapper);
+
+/* retire a mapper id, previously acquired from omap_drm_register_mapper()
+ */
+void omap_drm_unregister_mapper(int mapper_id)
+{
+	/* currently no-op.. */
+}
+EXPORT_SYMBOL(omap_drm_unregister_mapper);
+
 static int pdev_suspend(struct platform_device *pDevice, pm_message_t state)
 {
 	DBG("");
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.h b/drivers/gpu/drm/omapdrm/omap_drv.h
index 428b2981..16a7981 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.h
+++ b/drivers/gpu/drm/omapdrm/omap_drv.h
@@ -232,6 +232,8 @@ int omap_gem_mmap(struct file *filp, struct vm_area_struct *vma);
 int omap_gem_mmap_obj(struct drm_gem_object *obj,
 		struct vm_area_struct *vma);
 int omap_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
+void omap_gem_vm_open(struct vm_area_struct *vma);
+void omap_gem_vm_close(struct vm_area_struct *vma);
 int omap_gem_op_start(struct drm_gem_object *obj, enum omap_gem_op op);
 int omap_gem_op_finish(struct drm_gem_object *obj, enum omap_gem_op op);
 int omap_gem_op_sync(struct drm_gem_object *obj, enum omap_gem_op op);
diff --git a/drivers/gpu/drm/omapdrm/omap_gem.c b/drivers/gpu/drm/omapdrm/omap_gem.c
index 83c1548..f17a140 100644
--- a/drivers/gpu/drm/omapdrm/omap_gem.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem.c
@@ -118,6 +118,8 @@ struct omap_gem_object {
 		uint32_t read_complete;
 	} *sync;
 
+	struct omap_gem_vm_ops *ops;
+
 	/**
 	 * per-mapper private data..
 	 *
@@ -313,6 +315,21 @@ uint32_t omap_gem_flags(struct drm_gem_object *obj)
 {
 	return to_omap_bo(obj)->flags;
 }
+EXPORT_SYMBOL(omap_gem_flags);
+
+void * omap_gem_priv(struct drm_gem_object *obj, int mapper_id)
+{
+	BUG_ON((mapper_id >= MAX_MAPPERS) || (mapper_id < 0));
+	return to_omap_bo(obj)->priv[mapper_id];
+}
+EXPORT_SYMBOL(omap_gem_priv);
+
+void omap_gem_set_priv(struct drm_gem_object *obj, int mapper_id, void *priv)
+{
+	BUG_ON((mapper_id >= MAX_MAPPERS) || (mapper_id < 0));
+	to_omap_bo(obj)->priv[mapper_id] = priv;
+}
+EXPORT_SYMBOL(omap_gem_set_priv);
 
 /** get mmap offset */
 static uint64_t mmap_offset(struct drm_gem_object *obj)
@@ -342,6 +359,7 @@ uint64_t omap_gem_mmap_offset(struct drm_gem_object *obj)
 	mutex_unlock(&obj->dev->struct_mutex);
 	return offset;
 }
+EXPORT_SYMBOL(omap_gem_mmap_offset);
 
 /** get mmap size */
 size_t omap_gem_mmap_size(struct drm_gem_object *obj)
@@ -374,6 +392,7 @@ int omap_gem_tiled_size(struct drm_gem_object *obj, uint16_t *w, uint16_t *h)
 	}
 	return -EINVAL;
 }
+EXPORT_SYMBOL(omap_gem_tiled_size);
 
 /* Normal handling for the case of faulting in non-tiled buffers */
 static int fault_1d(struct drm_gem_object *obj,
@@ -559,6 +578,30 @@ fail:
 	}
 }
 
+void omap_gem_vm_open(struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct omap_gem_object *omap_obj = to_omap_bo(obj);
+
+	if (omap_obj->ops && omap_obj->ops->open) {
+		omap_obj->ops->open(vma);
+	} else {
+		drm_gem_vm_open(vma);
+	}
+}
+
+void omap_gem_vm_close(struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct omap_gem_object *omap_obj = to_omap_bo(obj);
+
+	if (omap_obj->ops && omap_obj->ops->close) {
+		omap_obj->ops->close(vma);
+	} else {
+		drm_gem_vm_close(vma);
+	}
+}
+
 /** We override mainly to fix up some of the vm mapping flags.. */
 int omap_gem_mmap(struct file *filp, struct vm_area_struct *vma)
 {
@@ -605,6 +648,9 @@ int omap_gem_mmap_obj(struct drm_gem_object *obj,
 
 		vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 	}
+	if (omap_obj->ops && omap_obj->ops->mmap) {
+		omap_obj->ops->mmap(obj->filp, vma);
+	}
 
 	return 0;
 }
@@ -818,6 +864,7 @@ fail:
 
 	return ret;
 }
+EXPORT_SYMBOL(omap_gem_get_paddr);
 
 /* Release physical address, when DMA is no longer being performed.. this
  * could potentially unpin and unmap buffers from TILER
@@ -849,6 +896,7 @@ fail:
 	mutex_unlock(&obj->dev->struct_mutex);
 	return ret;
 }
+EXPORT_SYMBOL(omap_gem_put_paddr);
 
 /* Get rotated scanout address (only valid if already pinned), at the
  * specified orientation and x,y offset from top-left corner of buffer
@@ -879,6 +927,7 @@ int omap_gem_tiled_stride(struct drm_gem_object *obj, uint32_t orient)
 		ret = tiler_stride(gem2fmt(omap_obj->flags), orient);
 	return ret;
 }
+EXPORT_SYMBOL(omap_gem_tiled_stride);
 
 /* acquire pages when needed (for example, for DMA where physically
  * contiguous buffer is not required
@@ -928,6 +977,7 @@ int omap_gem_get_pages(struct drm_gem_object *obj, struct page ***pages,
 	mutex_unlock(&obj->dev->struct_mutex);
 	return ret;
 }
+EXPORT_SYMBOL(omap_gem_get_pages);
 
 /* release pages when DMA no longer being performed */
 int omap_gem_put_pages(struct drm_gem_object *obj)
@@ -938,6 +988,7 @@ int omap_gem_put_pages(struct drm_gem_object *obj)
 	 */
 	return 0;
 }
+EXPORT_SYMBOL(omap_gem_put_pages);
 
 /* Get kernel virtual address for CPU access.. this more or less only
  * exists for omap_fbdev.  This should be called with struct_mutex
@@ -1136,6 +1187,7 @@ void omap_gem_op_update(void)
 	sync_op_update();
 	spin_unlock(&sync_lock);
 }
+EXPORT_SYMBOL(omap_gem_op_update);
 
 /* mark the start of read and/or write operation */
 int omap_gem_op_start(struct drm_gem_object *obj, enum omap_gem_op op)
@@ -1245,6 +1297,7 @@ int omap_gem_op_async(struct drm_gem_object *obj, enum omap_gem_op op,
 
 	return 0;
 }
+EXPORT_SYMBOL(omap_gem_op_async);
 
 /* special API so PVR can update the buffer to use a sync-object allocated
  * from it's sync-obj heap.  Only used for a newly allocated (from PVR's
@@ -1282,6 +1335,7 @@ unlock:
 	spin_unlock(&sync_lock);
 	return ret;
 }
+EXPORT_SYMBOL(omap_gem_set_sync_object);
 
 /* don't call directly.. called from GEM core when it is time to actually
  * free the object..
@@ -1350,9 +1404,10 @@ int omap_gem_new_handle(struct drm_device *dev, struct drm_file *file,
 	return 0;
 }
 
-/* GEM buffer object constructor */
-struct drm_gem_object *omap_gem_new(struct drm_device *dev,
-		union omap_gem_size gsize, uint32_t flags)
+/* common constructor body */
+static struct drm_gem_object * omap_gem_new_impl(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags, unsigned long paddr, void *vaddr,
+        struct page **pages, struct omap_gem_vm_ops *ops)
 {
 	struct omap_drm_private *priv = dev->dev_private;
 	struct omap_gem_object *omap_obj;
@@ -1396,18 +1451,11 @@ struct drm_gem_object *omap_gem_new(struct drm_device *dev,
 
 	obj = &omap_obj->base;
 
-	if ((flags & OMAP_BO_SCANOUT) && !priv->has_dmm) {
-		/* attempt to allocate contiguous memory if we don't
-		 * have DMM for remappign discontiguous buffers
-		 */
-		omap_obj->vaddr =  dma_alloc_writecombine(dev->dev, size,
-				&omap_obj->paddr, GFP_KERNEL);
-		if (omap_obj->vaddr)
-			flags |= OMAP_BO_DMA;
-
-	}
-
 	omap_obj->flags = flags;
+	omap_obj->pages = pages;
+	omap_obj->ops   = ops;
+	omap_obj->paddr = paddr;
+	omap_obj->vaddr = vaddr;
 
 	if (flags & OMAP_BO_TILED) {
 		omap_obj->width = gsize.tiled.width;
@@ -1432,6 +1480,40 @@ fail:
 	return NULL;
 }
 
+/* GEM buffer object constructor */
+struct drm_gem_object *omap_gem_new(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags)
+{
+	size_t size;
+	dma_addr_t paddr = 0;
+	void *vaddr = NULL;
+
+	if ((flags & OMAP_BO_SCANOUT) && !dmm_is_available()) {
+		/* attempt to allocate contiguous memory if we don't
+		 * have DMM for remappign discontiguous buffers
+		 */
+		size = PAGE_ALIGN(gsize.bytes);
+		vaddr =  dma_alloc_writecombine(dev->dev, size,	&paddr, GFP_KERNEL);
+		if (vaddr)
+			flags |= OMAP_BO_DMA;
+
+	}
+	return omap_gem_new_impl(dev, gsize, flags, paddr, vaddr, NULL, NULL);
+}
+EXPORT_SYMBOL(omap_gem_new);
+
+/* This constructor is mainly to give plugins a way to wrap their
+ * own allocations
+ */
+struct drm_gem_object * omap_gem_new_ext(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags, unsigned long paddr, struct page **pages,
+		struct omap_gem_vm_ops *ops)
+{
+	return omap_gem_new_impl(dev, gsize, flags | OMAP_BO_EXT_MEM,
+			paddr, NULL, pages, ops);
+}
+EXPORT_SYMBOL(omap_gem_new_ext);
+
 /* init/cleanup.. if DMM is used, we need to set some stuff up.. */
 void omap_gem_init(struct drm_device *dev)
 {
diff --git a/include/uapi/drm/omap_drm.h b/include/uapi/drm/omap_drm.h
index 1d0b117..08b79f0 100644
--- a/include/uapi/drm/omap_drm.h
+++ b/include/uapi/drm/omap_drm.h
@@ -120,4 +120,76 @@ struct drm_omap_gem_info {
 #define DRM_IOCTL_OMAP_GEM_CPU_FINI	DRM_IOW (DRM_COMMAND_BASE + DRM_OMAP_GEM_CPU_FINI, struct drm_omap_gem_cpu_fini)
 #define DRM_IOCTL_OMAP_GEM_INFO		DRM_IOWR(DRM_COMMAND_BASE + DRM_OMAP_GEM_INFO, struct drm_omap_gem_info)
 
+
+/*
+ * pvr door below
+ */
+void * omap_drm_file_priv(struct drm_file *file, int mapper_id);
+void omap_drm_file_set_priv(struct drm_file *file, int mapper_id, void *priv);
+
+/* interface that plug-in drivers can implement */
+struct omap_drm_plugin {
+	const char *name;
+
+	/* drm functions */
+	int (*open)(struct drm_device *dev, struct drm_file *file);
+	int (*load)(struct drm_device *dev, unsigned long flags);
+	int (*unload)(struct drm_device *dev);
+	int (*release)(struct drm_device *dev, struct drm_file *file);
+
+	struct drm_ioctl_desc *ioctls;
+	int num_ioctls;
+	int ioctl_base;
+
+	struct list_head list;  /* note, this means struct can't be const.. */
+};
+
+int omap_drm_register_plugin(struct omap_drm_plugin *plugin);
+int omap_drm_unregister_plugin(struct omap_drm_plugin *plugin);
+
+int omap_drm_register_mapper(void);
+void omap_drm_unregister_mapper(int id);
+
+/* external mappers should get paddr or pages when it needs the pages pinned
+ * and put when done..
+ */
+int omap_gem_get_paddr(struct drm_gem_object *obj, dma_addr_t *paddr, bool remap);
+int omap_gem_put_paddr(struct drm_gem_object *obj);
+int omap_gem_get_pages(struct drm_gem_object *obj, struct page ***pages, bool remap);
+int omap_gem_put_pages(struct drm_gem_object *obj);
+
+uint32_t omap_gem_flags(struct drm_gem_object *obj);
+void * omap_gem_priv(struct drm_gem_object *obj, int mapper_id);
+void omap_gem_set_priv(struct drm_gem_object *obj, int mapper_id, void *priv);
+uint64_t omap_gem_mmap_offset(struct drm_gem_object *obj);
+
+/* for external plugin buffers wrapped as GEM object (via. omap_gem_new_ext())
+ * a vm_ops struct can be provided to get callback notification of various
+ * events..
+ */
+struct omap_gem_vm_ops {
+	void (*open)(struct vm_area_struct * area);
+	void (*close)(struct vm_area_struct * area);
+
+	/* note: mmap is not expected to do anything.. it is just to allow buffer
+	 * allocate to update it's own internal state
+	 */
+	void (*mmap)(struct file *, struct vm_area_struct *);
+};
+
+struct drm_gem_object * omap_gem_new_ext(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags, unsigned long paddr, struct page **pages,
+		struct omap_gem_vm_ops *ops);
+struct drm_gem_object *omap_gem_new(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags);
+
+void omap_gem_op_update(void);
+int omap_gem_op_start(struct drm_gem_object *obj, enum omap_gem_op op);
+int omap_gem_op_finish(struct drm_gem_object *obj, enum omap_gem_op op);
+int omap_gem_op_sync(struct drm_gem_object *obj, enum omap_gem_op op);
+int omap_gem_op_async(struct drm_gem_object *obj, enum omap_gem_op op,
+        void (*fxn)(void *arg), void *arg);
+int omap_gem_set_sync_object(struct drm_gem_object *obj, void *syncobj);
+
+
 #endif /* __OMAP_DRM_H__ */
-- 
1.8.3.1

